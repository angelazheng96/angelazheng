---
import "../styles/global.css";

const { url, frontmatter } = Astro.props;
---

<button
  onclick={`window.location.href='${url}'`}
  class="w-full max-w-md p-3 md:p-4 border-2 border-lilac/50 rounded-lg hover:scale-102 hover:shadow-lg hover:shadow-salmon/20 dark:hover:shadow-rose/20 hover:cursor-pointer transition-transform duration-200"
>
  <div
    class="font-semibold text-eggplant dark:text-lilac text-lg md:text-xl my-1 md:my-2"
  >
    {frontmatter.title}
  </div>
  <div class="text-sm md:text-base my-1 md:my-2">{frontmatter.description}</div>

  <!-- Combined Tags and Tech Stack Section -->
  <div class="mt-3 md:mt-4">
    <div class="tag-scroller overflow-hidden relative" data-speed="0.6">
      <div
        class="tag-track flex whitespace-nowrap gap-1.5 md:gap-2 will-change-transform"
      >
        {
          frontmatter.tags &&
            frontmatter.tags.map((tag) => (
              <span class="bg-eggplant/50 text-white rounded-md px-2 md:px-3 py-0.5 md:py-1 text-xs md:text-sm whitespace-nowrap">
                {tag}
              </span>
            ))
        }
        {
          frontmatter.techStack &&
            frontmatter.techStack.map((tech) => (
              <span class="bg-teal/50 text-white rounded-md px-2 md:px-3 py-0.5 md:py-1 text-xs md:text-sm whitespace-nowrap">
                {tech}
              </span>
            ))
        }
      </div>
    </div>
  </div>
</button>

<style>
  /* keep visible area clean */
  .tag-scroller {
    -webkit-overflow-scrolling: touch;
  }
  .tag-track {
    transform: translateX(0);
  }
</style>

<script is:inline>
  // Auto-scroll tags only when they overflow the container.
  // Uses requestAnimationFrame for smooth scrolling and clones content to avoid gaps.
  (function () {
    const scrollers = document.querySelectorAll(".tag-scroller");
    scrollers.forEach((scroller) => {
      const track = scroller.querySelector(".tag-track");
      if (!track) return;

      // If content does NOT overflow, center the tags and do nothing else.
      if (track.scrollWidth <= scroller.clientWidth) {
        track.style.justifyContent = "center";
        return;
      }

      // Duplicate content to create a seamless loop.
      track.innerHTML = track.innerHTML + track.innerHTML;

      const speed = parseFloat(scroller.dataset.speed) || 0.6; // pixels per frame
      let pos = 0;
      const singleWidth = track.scrollWidth / 2;

      let paused = false;
      scroller.addEventListener("mouseenter", () => (paused = true));
      scroller.addEventListener("mouseleave", () => (paused = false));

      function step() {
        if (!paused) {
          pos += speed;
          if (pos >= singleWidth) pos = 0;
          track.style.transform = `translateX(-${pos}px)`;
        }
        requestAnimationFrame(step);
      }

      // Start animation
      requestAnimationFrame(step);
    });
  })();
</script>
